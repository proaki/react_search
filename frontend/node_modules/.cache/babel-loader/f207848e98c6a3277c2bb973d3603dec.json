{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observe = observe;\nexports.unobserve = unobserve;\nexports.destroy = destroy;\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\n\nfunction observe(element, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    threshold: 0\n  };\n  var rootId = arguments[3];\n  var root = options.root,\n      rootMargin = options.rootMargin;\n  var threshold = options.threshold || 0;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : \"\" + threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n  INSTANCE_MAP.set(element, instance);\n  observerInstance.observe(element);\n  return instance;\n}\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\n\n\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var _observerId = instance.observerId,\n        _observer = instance.observer;\n    var observerInstance = _observerId ? OBSERVER_MAP.get(_observerId) : _observer;\n\n    if (observerInstance) {\n      // $FlowFixMe - the interface in bom.js is wrong. Spec should accept the element.\n      observerInstance.unobserve(element);\n    } // Check if we are still observing any elements with the same threshold.\n\n\n    var itemsLeft = false;\n\n    if (_observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === _observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(_observerId);\n    } // Remove reference to element\n\n\n    INSTANCE_MAP.delete(element);\n  }\n}\n/**\n * Destroy all IntersectionObservers currently connected\n **/\n\n\nfunction destroy() {\n  OBSERVER_MAP.forEach(function (observer) {\n    observer.disconnect();\n  });\n  OBSERVER_MAP.clear();\n  INSTANCE_MAP.clear();\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n    var instance = INSTANCE_MAP.get(target); // Firefox can report a negative intersectionRatio when scrolling. Ignore this, and\n\n    if (instance && intersectionRatio >= 0) {\n      var _options = instance.options;\n      var _inView = false;\n\n      if (Array.isArray(_options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = _options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (_options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > _options.threshold : intersectionRatio >= _options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      if (instance.callback) {\n        instance.callback(_inView);\n      }\n    }\n  });\n}\n\nexports.default = {\n  observe: observe,\n  unobserve: unobserve,\n  destroy: destroy\n};","map":{"version":3,"sources":["/Users/akihiro/project/react_search/node_modules/react-intersection-observer/lib/intersection.js"],"names":["Object","defineProperty","exports","value","observe","unobserve","destroy","INSTANCE_MAP","Map","OBSERVER_MAP","element","callback","options","arguments","length","undefined","threshold","rootId","root","rootMargin","observerId","toString","observerInstance","get","IntersectionObserver","onChange","set","instance","visible","observer","_observerId","_observer","itemsLeft","forEach","item","key","disconnect","delete","clear","changes","intersection","isIntersecting","intersectionRatio","target","_options","_inView","Array","isArray","some","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observe = observe;\nexports.unobserve = unobserve;\nexports.destroy = destroy;\nvar INSTANCE_MAP = new Map();\nvar OBSERVER_MAP = new Map();\n\n/**\n * Monitor element, and trigger callback when element becomes visible\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be visible before triggering\n * @param options.root {HTMLElement} It should have a unique id or data-intersection-id in order for the Observer to reused.\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n * @param rootId {String} Unique identifier for the root element, to enable reusing the IntersectionObserver\n */\nfunction observe(element, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    threshold: 0\n  };\n  var rootId = arguments[3];\n  var root = options.root,\n      rootMargin = options.rootMargin;\n\n  var threshold = options.threshold || 0;\n  if (!element || !callback) return;\n  var observerId = rootMargin ? threshold.toString() + \"_\" + rootMargin : \"\" + threshold.toString();\n\n  if (root) {\n    observerId = rootId ? rootId + \"_\" + observerId : null;\n  }\n\n  var observerInstance = observerId ? OBSERVER_MAP.get(observerId) : null;\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options);\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance);\n  }\n\n  var instance = {\n    callback: callback,\n    visible: false,\n    options: options,\n    observerId: observerId,\n    observer: !observerId ? observerInstance : undefined\n  };\n\n  INSTANCE_MAP.set(element, instance);\n\n  observerInstance.observe(element);\n\n  return instance;\n}\n\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {HTMLElement}\n */\nfunction unobserve(element) {\n  if (!element) return;\n  var instance = INSTANCE_MAP.get(element);\n\n  if (instance) {\n    var _observerId = instance.observerId,\n        _observer = instance.observer;\n\n    var observerInstance = _observerId ? OBSERVER_MAP.get(_observerId) : _observer;\n\n    if (observerInstance) {\n      // $FlowFixMe - the interface in bom.js is wrong. Spec should accept the element.\n      observerInstance.unobserve(element);\n    }\n\n    // Check if we are still observing any elements with the same threshold.\n    var itemsLeft = false;\n    if (_observerId) {\n      INSTANCE_MAP.forEach(function (item, key) {\n        if (item && item.observerId === _observerId && key !== element) {\n          itemsLeft = true;\n        }\n      });\n    }\n\n    if (observerInstance && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observerInstance.disconnect();\n      OBSERVER_MAP.delete(_observerId);\n    }\n\n    // Remove reference to element\n    INSTANCE_MAP.delete(element);\n  }\n}\n\n/**\n * Destroy all IntersectionObservers currently connected\n **/\nfunction destroy() {\n  OBSERVER_MAP.forEach(function (observer) {\n    observer.disconnect();\n  });\n\n  OBSERVER_MAP.clear();\n  INSTANCE_MAP.clear();\n}\n\nfunction onChange(changes) {\n  changes.forEach(function (intersection) {\n    var isIntersecting = intersection.isIntersecting,\n        intersectionRatio = intersection.intersectionRatio,\n        target = intersection.target;\n\n    var instance = INSTANCE_MAP.get(target);\n\n    // Firefox can report a negative intersectionRatio when scrolling. Ignore this, and\n    if (instance && intersectionRatio >= 0) {\n      var _options = instance.options;\n\n      var _inView = false;\n\n      if (Array.isArray(_options.threshold)) {\n        // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n        _inView = _options.threshold.some(function (threshold) {\n          return instance.visible ? intersectionRatio > threshold : intersectionRatio >= threshold;\n        });\n      } else if (_options.threshold !== undefined) {\n        // Trigger on 0 ratio only when not visible. This is fallback for browsers without isIntersecting support\n        _inView = instance.visible ? intersectionRatio > _options.threshold : intersectionRatio >= _options.threshold;\n      }\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        _inView = _inView && isIntersecting;\n      }\n\n      if (instance.callback) {\n        instance.callback(_inView);\n      }\n    }\n  });\n}\n\nexports.default = {\n  observe: observe,\n  unobserve: unobserve,\n  destroy: destroy\n};"]},"metadata":{},"sourceType":"script"}